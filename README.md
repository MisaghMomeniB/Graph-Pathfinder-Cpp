# 🧭 Graph Pathfinder (C++)

A C++ implementation of **graph pathfinding algorithms**, focused on readability and performance. Ideal for learning and integrating into game engines, network analysis tools, or routing systems.

---

## 📋 Table of Contents

1. [Overview](#overview)  
2. [Features](#features)  
3. [Algorithms Implemented](#algorithms-implemented)  
4. [Installation & Build](#installation--build)  
5. [Usage Examples](#usage-examples)  
6. [Code Structure](#code-structure)  
7. [Performance & Complexity](#performance--complexity)  
8. [Contributing](#contributing)  
9. [License](#license)

---

## 💡 Overview

This project provides clean, modern C++ implementations of path-finding algorithms on weighted graphs. It’s built with **C++17**, leveraging `std::vector`, `std::priority_queue`, and expressive templates. The code is written for both standalone CLI tests and easy integration into game or simulation engines.

---

## ✅ Features

- 📈 **Multiple algorithms** – Choose between Dijkstra, A\*, and Bellman-Ford  
- 🧩 **Weighted & Directional Graphs** – Supports directed, undirected, and weighted edges  
- 🏁 **CLI Example App** – Load graphs from text files and compute shortest paths  
- 📊 **Path Reconstruction** – Recover the actual path and display its cost  
- 🧪 **Edge Cases Handling** – Negative cycle detection with Bellman-Ford

---

## 🧠 Algorithms Implemented

- **Dijkstra's Algorithm** – Guaranteed shortest path for non-negative weights  
- **A\*** – Heuristic-based search with customizable heuristics  
- **Bellman–Ford** – Supports negative weights and cycle detection  

---

## ⚙️ Installation & Build

**Prerequisites**:  
- C++17-compatible compiler (`g++`, `clang++`, MSVC)
- CMake (optional but recommended)

**Build from source**:
```bash
git clone https://github.com/MisaghMomeniB/Graph-Pathfinder-Cpp.git
cd Graph-Pathfinder-Cpp
mkdir build && cd build
cmake ..
make
````

After building, you’ll get:

* `graph_pathfinder` CLI executable
* `libgraph_pathfinder.a` static library (in `build/lib`)
* Headers (in `include/`)

---

## 🚀 Usage Examples

### CLI Usage

Assuming a graph file `simple_graph.txt` with:

```
5 6
0 1 2.5
0 2 1.5
1 3 1.0
2 3 2.0
2 4 3.0
3 4 1.2
```

Run:

```bash
./graph_pathfinder --algo dijkstra --input simple_graph.txt --start 0 --end 4
```

Expected output:

```
Path found: 0 -> 2 -> 3 -> 4
Total cost: 4.7
```

### Library Integration

```cpp
#include "GraphPathfinder.hpp"

int main() {
    Graph g(5);
    g.addEdge(0,1,2.5);
    g.addEdge(0,2,1.5);
    g.addEdge(1,3,1.0);
    g.addEdge(2,3,2.0);
    g.addEdge(2,4,3.0);
    g.addEdge(3,4,1.2);

    Pathfinder pf(g);
    auto result = pf.aStar(0, 4, [](int u, int v){
        // Zero heuristic—equivalent to Dijkstra
        return 0.0;
    });

    if (result.found) {
        std::cout << "Path: ";
        for (auto n : result.path) std::cout << n << " ";
        std::cout << "\nCost: " << result.cost << "\n";
    }
    return 0;
}
```

---

## 🧱 Code Structure

```
Graph-Pathfinder-Cpp/
├── src/
│   ├── Graph.cpp
│   ├── GraphPathfinder.cpp
│   └── main.cpp          # CLI entry
├── include/
│   ├── Graph.hpp
│   └── GraphPathfinder.hpp
├── build/                # Generated by CMake
└── README.md             # This file
```

---

## 📊 Performance & Complexity

| Algorithm    | Time Complexity            | Space Complexity | Notes                            |
| ------------ | -------------------------- | ---------------- | -------------------------------- |
| Dijkstra     | O((V + E) log V)           | O(V + E)         | For non-negative edge weights    |
| A\*          | O((V + E) log V) best-case | O(V + E)         | With good heuristic (admissible) |
| Bellman–Ford | O(V·E)                     | O(V + E)         | Detects negative cycles          |

---

## 🤝 Contributing

Contributions and improvements are welcome!

* Add BFS-based unweighted search
* Implement additional heuristics or optimizations
* Add path visualization support (e.g., GraphViz)
* Improve CLI with format flags or verbose mode

To contribute:

1. Fork it
2. Create a branch (`feature/…`)
3. Submit a Pull Request describing your changes

---

## 📄 License

This project is licensed under the **MIT License**. See the [LICENSE](LICENSE) file for details.
